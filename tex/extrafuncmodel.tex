\section{Problem Model}\label{sec_extrafunc}
The software allocation problem is a type of job shop scheduling with constraints, as such it is a discrete optimization problem \cite{}. The solution to the allocation problem is represented by a matrix $\textbf{x}$ of size $N_c\times K$, where $N_c$ is the number of component types and $K=Max(K_i)$ is the maximum replica size of type $c_i$, where $x_{ij}=k\in \{1,â€¦,N_m\}$ represents the mapping of the software component replica $c_{ij}$ to the computation node $m_k$.
\begin{equation}
\label{fig_pso_solution_representation}
\textbf{x}=
\begin{bmatrix} 
x_{11} & x_{12} & \dots & x_{1K}\\
x_{21} & x_{22} & \dots & x_{2K}\\
\vdots & \vdots & \ddots & \vdots\\
x_{I1} & x_{I2} & \cdots & x_{IK}
\end{bmatrix}
\end{equation}

In this work, the main objective of the allocation problem is to satisfy the user-defined requirements, namely reliability requirements, end-to-end timing requirements, and criticality of the software applications $A_i$ by effectively mapping the software components to the computation nodes, $C\mapsto M$. Furthermore, the components are allocated efficiently to minimize the total power consumption $Power(\textbf{x})=\sum_{m\in M'}{P_{m}(\textbf{x})}$ of the applications by selecting lower-power consuming nodes $M'\subseteq M$, provided the requirements are met, where $P_{m}(\textbf{x})$ is the power consumption of node $m$ on the mapping $\textbf{x}$. Power consumption, in this context, refers to the energy usage of electronic components in the integrated circuits of the node, e.g., processor, memory, I/O devices, etc., per time unit. 

%Power consumption refers to the energy usage of electronic components in an integrated circuit, e.g., processor, memory, I/O devices, etc., per time unit. 
There are several power consumption models and different techniques to estimate the power consumption of a computing node. In this work, we employ a technique based on processor load (or \textit{Processor Utilization}) to estimate the average power consumption of a computation node. Specifically, we use the linear polynomial model proposed by Fan et al. \cite{Fan2007PowerComputer}, which is shown in (\ref{eqn_powerconsumption}). The mode states that the power consumption of a node is directly proportional to its load, and is inductively formulated from experimental results:
\begin{equation}
\label{eqn_powerconsumption}
f_p(u)=P_{idle} + (P_{busy}-P_{idle})*u,
\end{equation}

where $u$ is the utilization (or load) of a computation node, $p_{idle}$ and $p_{busy}$, respectively, refer to the power consumption of a node measured at minimum and maximum processor loads. Such measurements can be obtained by running performance benchmark suits, e.g., MiBench \cite{Guthaus2001MiBench:Suite}, AutoBench \cite{EMBC2018AutoBenchProcessors}, etc., which is computed based on the utilization of the node via the linear power consumption model shown in Equation (\ref{eqn_powerconsumption}).

Consequently, the power consumption of a node $m$ for a given mapping $\textbf{x}$ is computed using Equations (\ref{eqn_powerconsumption_x}-\ref{eqn_util_component}), by calculating first the node's utilization $U_m(\textbf{x})$ using Equation (\ref{eqn_util_x}). The node's utilization is computed from the set of components allocated to it (which are $\forall_{ij} x_{ij}=m$) using Equation (\ref{eqn_util_x}). And the utilization of a component on the node $m$ is computed from its constituent tasks $T_c$ using Equation (\ref{eqn_util_component}).
\begin{align}
	\label{eqn_powerconsumption_x}
P_m(\textbf{x}) & =f_p(U_m(\textbf{x}))                         &  \\
	\label{eqn_util_x}
U_{m}(\textbf{x})           & = \sum_{i}{\sum_{j}{U_{c_i}}(x_{ij})}         & \text{: }x_{ij}=m \\
	\label{eqn_util_component}
U_c(m)              & = \sum_{\tau\in T_c} \frac{\tau.e_m}{\tau.P}, &
\end{align}

The applications requirements are modeled as constraints that need to be satisfied in the allocation problem. The constraints formulations are shown in the following subsections, respectively for reliability, timing and other design constraints such as related to runnables-to-tasks merging and replication.

%\begin{figure*}[h!]
%    \centering
%    \begin{subfigure}[b]{0.25\textwidth}
%    \includegraphics[trim=0 0 0 0,clip,width=\textwidth]{datachain_singlenode}
%    \caption{Deployment on a Single Node.}
%    \label{fig_datachainsingle}
%    \end{subfigure}
%    ~ %\quad, \qquad, \hfill 
%    \begin{subfigure}[b]{0.365\textwidth}
%    \includegraphics[trim=0 0 0 0,clip,width=\textwidth]{datachain_multinode}
%    \caption{Deployment on Multiple Nodes.}
%    \label{fig_datachainmulti}
%    \end{subfigure}
%   ~\vspace{-0.2cm}
%    \begin{subfigure}[b]{0.35\textwidth}
%    \includegraphics[width=\textwidth]{timedpath}
%    \caption{Timed Paths of Age and Reaction Delays.}
%    \label{fig_timedpath}
%    \end{subfigure}
%    \caption{Cause-effect Chain with Three Activation Patterns.}
%    \label{fig:datachain}
%\end{figure*}

\subsection{Software Application Reliability Constraint}\label{subsec_reliability_constraint}
The applications reliability constraints ensure the mapping solution $\textbf{x}$ satisfies the user-defined reliability requirements, that is $ \forall i\in [1,N_a]\ \rel_{A_i}(\textbf{x})\leq RelReq_{A_i}$. 
The reliability of a software application is computed from the execution framework part that is responsible to run the application, that is from the computation nodes $M^{'}_{A_i}\in M$ where $C_{A_i}\mapsto M'$ and the shared CAN bus \textbf{B}, consequently $Reliability_{A_i}(\textbf{x})=Reliability(M')*Reliability(B)$. The reliability of the nodes $Reliability(M')$ is calculated using the \textit{state-enumeration} technique \cite{Lucet1999ExactReliability}  as shown in Equations (\ref{eqn_appreliability}). According to the technique, the reliability is basically the total probability that the application $A_i$ \textit{functions} under the mutually exclusive events of the nodes failures  (or state-space) $PS_{A_i}(\textbf{x})=\{0,1\}^{M'}$, where  0 - the node fails, 1 - the node is operational, e.g., for $M'=\{m_1,m_2,m_3\}$ implies $PS_{A_i}=\{001,010,011,...,111\}$. We refer to the state of a node $m\in M'$ for $s\in PS_{A_i}$ as $s.Index(m)\in\{0,1\}$. 
\begin{align}
\label{eqn_appreliability}
Reliability(M')&=\sum_{s\in PS_{A_i}|g(A_i, s)=1}probability(s)
\end{align}

For a mapping solutoin $\textbf{x}$ and some event of nodes failures $s\in PS_{A_i}$, the fact that an application fails or not is deductively defined as follows:
\begin{definition}[Software Application Failure]
The application $A_i$ \textit{fails}  in the event $s$, that is $g(a, s)=0$ (\ref{eqn_app_failure}), if there exists a component type $c_i$ where all of its replica $Q_i$ \textit{fails}, otherwise, the application functions.  A component replica $q_{ij}\in Q_i$ fails if the node $m_k$ that host it fails, where $k=x_{ij}$. 
\begin{align}
\label{eqn_app_failure}
g(a, s)&=
\begin{cases}
\textbf{0} \mbox{ (fails)} & \mbox{if }  \prod_{m\in M^{''}}{h(m,s)}\\
\textbf{1} \mbox{ (functions)} & \mbox{otherwise }
\end{cases}\\
\label{eqn_appreliability_node}
h(m, s)&=
\begin{cases}
\textbf{1} & \mbox{if } s.Index(m) = 1\\
\textbf{0} & \mbox{otherwise }
\end{cases}
\end{align}

where $M^{''}={m\in M'|}$
 %c \in C_a\forall q\in Q_i \ldotp h(m,s)=1
 %of its components are \textit{running} under a given mapping $\textbf{x}$ and state $s\in PS_{A_i}(\textbf{x})$. 
\end{definition}
%WeAn application functions (which is indicated by \textbf{1}, otherwise \textbf{0}) if all of its components are \textit{running} under a given mapping $\textbf{x}$ and state $s\in PS_{A_i}(\textbf{x})$.  A component runs (or is alive) (which is indicated by \textbf{1}, otherwise \textbf{0}) under the mapping $\textbf{x}$ and state $s\in PS_{A_i}(\textbf{x})$ if the node that hosts the component \textit{functions}, which is determined using Equation (\ref{eqn_appreliability_node}).
%\begin{align}
%	g(a, s)&=
%	\begin{cases}
%	\textbf{1} & \mbox{if } \forall c\in C_a\ldotp\exists m\in M'\ldotp h(m,s)=1\\
%	\textbf{0} & \mbox{otherwise }
%	\end{cases}\\
%	\label{eqn_appreliability_node}
%	h(m, s)&=
%	\begin{cases}
%	\textbf{1} & \mbox{if } s.Index(m) = 1\\
%	\textbf{0} & \mbox{otherwise }
%	\end{cases}
%\end{align}

%, e.g., if s={0,1,1} respectively for $\{m_1,m_2,m_3\}$, $stateOf(m_1,s)$=0%, are functioning (that is )and  $Reliability(B)\in [0,1]$ is the reliability of the share CAN bus.

%where $PS_{A_i}={Fail=0,Function=1}^{|M'|]}$ is the enumerated state-space of $M'$, $g(s):PS_{A_i}\rightarrow {Fail, Function}
% where  as Note: we assume the communication is reliable.
%\textit{Application reliability} $R_a$ refers to the probability that a software application functions correctly by the time $t$, or within the time interval $[0, t]$ \cite{Goel1985SoftwareApplicability}. We assume that  applications are free from design errors and, therefore, an application failure can be caused only by failures from the computational nodes in which the application is deployed. The failure rate of a node over time is represented by $\lambda(t)$, and the reliability of a node is represented by the exponential density function over constant failure rate $\lambda e^{-\lambda t}$, where $\lambda=\lambda(t)$.
%In a system without replication, the failure of any arbitrary node that hosts the software application renders the whole application faulty. Reliability calculation is then straightforward, using a series-parallel model: $R_a = \prod_{m\in M}r_m$.  However, with the introduction of replication, to enable fault tolerance, the reliability calculation is not straightforward due to the replicas of the same software component allocated to different nodes that result in functional interdependencies between nodes. A software application functions \textit{ correctly} if each software component is executed at least by one non-faulty node, and will be \textit{faulty} otherwise (i.e., if there are one or more software components that are allocated only to faulty nodes and thus these components cannot be executed correctly).

To calculate the reliability in such cases, we use state enumeration, which is one of the reliability-preserving methods that are used to compute the reliability of a system with dependent components (or subsystems) \cite{Lucet1999ExactReliability}. The state enumeration method allows the exploration of all possible states of a system in the probability space $P\!S$. Our goal is to differentiate between the states in which the application functions, denoted by \textit{Functions(s)}, and the states in which the application fails, denoted by \textit{Fails(s)}. The application reliability $R_a$ is then calculated as follows:
\begin{align}
\label{eqn_appreliability}
R_a=\sum_{s\in PS_{A_i}|Functions(s)}p_s=1-\sum_{s\in PS|Fails(s)}p_s\\
PS_{A_i}=2^{M_{A_i}}\\
g:\textbf{x}\rightarrow M_{A_i}
\end{align}

To obtain $p_s$, that means the probability that the application is in state $s\in PS$, we define the Boolean variable $z_m \in \{0,1\}$ to indicate whether a node $m \in M$ is either faulty, $z_m = 0$, or not, $z_m = 1$. Then, the probability is calculated using (Â´\ref{eqn_stateprobability}).
\begin{align}
\label{eqn_stateprobability}
p_s=\prod_{m\in M}((z_m*r_m) + (1-z_m)*(1-r_m)),
\end{align}
where $r_m$ and $1-r_m$ are a computation node's reliability and probability of failure, respectively.

\subsection{The Timing Model}
The software application can be considered as a set of cause-effect chains, which are directed paths in the application graph, e.g.,  activation of a cruise control system by pressing a rotary-wheel on the dashboard, slowing down of a car by pressing the brake pedal, etc. Each cause-effect chain is annotated with an end-to-end timing requirement that specifies the maximum time between a stimulus and the corresponding response of a chain. A cause-effect chain can be hosted on a single node or multiple nodes as illustrated in Figure \ref{fig_datachainsingle} and Figure \ref{fig_datachainmulti}, respectively. Moreover, it can be activated by a single activation pattern, or multiple activation patterns (multirate).

The calculation of data-propagation delays in multirate software applications is not trivial due to the oversampling and undersampling effects, caused by the different activation patterns. Consequently, there are different delay semantics, which differ depending on the timed paths through which the data is propagated from the input to the output of the chains~\cite{mubeen2013support}. In this work, we focus on the \textit{age} and \textit{reaction} delays, which are the most widely used delay semantics in the automotive embedded systems. The two delays in a cause-effect chain that is distributed over two nodes  are demonstrated in Figure~\ref{fig_timedpath}. The tasks t1 and t2 execute on one node, whereas task t3 executes on the second node. Note that t2 communicates with t3 via a network message, that is not shown in the figure for simplicity. The red inverted arrows in Figure~\ref{fig_timedpath} represent the arrival of events at the input of the chain, whereas the dashed-curve arrows represent the timed paths through which the data propagates from the input to the output of the chain. The age delay is the time elapsed between a stimulus and its corresponding latest non-overwritten response, i.e., between the $2^{nd}$ instance of t1 and the $5^{th}$ instance of t3. This delay is frequently used in the control systems applications where freshness of data is paramount. For example, the torque applied to turn the wheels must correspond to the position of the steering wheel and must be time bound. The reaction delay is the earliest time the system takes to respond to a stimulus that ``just missed" the read access at the input of the chain. Assume that an event occurs just after the start of execution of the $1^{st}$ instance of t1. The data corresponding to this event is not read by the current instance of t1. In fact, the data will be read by the $2^{nd}$ instance of t1. The earliest effect of this event at the output of the chain will appear at the $4^{th}$ instance of t3, which represents the reaction delay. This delay is useful in body-electronics domain where first reaction to events is important, e.g., in the button-to-reaction applications. We refer the reader to \cite{mubeen2013support} for the formal semantics of the two delays used in this paper.

\subsection{Software Allocation Optimization P}\label{sec_allocation}
In this section, we define the allocation problem of a fault-tolerant software application on a network of heterogeneous nodes which is formulatd as ann optimization problem as shown in Equation (\ref{eqn_const_func}). The optimization problem considers minimizing of power consumption $p(x)$ as the objective while fulfilling timing (\ref{eqn_timing}) and application reliability requirements (\ref{eqn_reliability}) of the software applications as well as satisfying design and hardware constraints, e.g., respecting affinity of software components to dedicated nodes.
\begin{align}
\label{eqn_optimization}
\min_{x\in X}\;\;& P(\textbf{x}) & \\
\text{Subj to:} &\\
& ResponseTime_i(\textbf{x}) \leq Deadline_i & \text{for }\tau_i\in T, i=1,2,...,N_\tau \\ 
\label{eqn_e2e}
&Delay_i(\textbf{x}) \leq EndToEnd_i & \text{for }\Gamma_i\in \Gamma, i=1,2,...,N_\Gamma \\
\label{eqn_reliability}
&Reliability_i(\textbf{x}) \leq RelReq_i & \text{for }a_i\in A, i=1,2,...,N_A\\
\label{eqn_mapping}
&StaticMapping_i(\textbf{x})\models \top & \text{for }c_i\in C, i=1,2,...,N_c
\end{align}
where $x\in X$ is a feasible solution from the search space
$X$, is the search space of the problem,  are a set of timing specification constraints, $Timing\in \Bbb R^n$ is a set of timing boundaries, and $c^{reliability}\in \Bbb R^n$ is a set of reliability boundaries.

In the rest of this section, we show the ILP model and the PSO algorithm of the software allocation problem, which are validated on an automotive use case and evaluated for performance in the next section. Throughout this section, we use a simple running example of a system model in order to demonstrate our proposed ILP model and the PSO optimization algorithm.

\subsection{Running Example}
The example employs an AUTOSAR system, which consists of a software application model and a hardware platform model, as well as functional and extra-functional requirements such as timing and reliability of the software application. The software application is modeled as a digraph of runnables, which is shown in Figure \ref{fig_application}. It consist of 50 runnables, 35 cause-effect chains (or paths), with their activation patterns and timing specifications shown in Table \ref{tbl_requirements}. The timing specifications of the runnables as well as the software components from which the runnables are instantiated are shown in Table \ref{tbl_comps_config}. The hardware platform model consists of three computation nodes, with specifications shown in Table \ref{tbl_nodes_specification}.
\begin{figure}[t!]
\centering
\includegraphics[width=0.8\linewidth]{dag}
\caption{A Directed Acyclic Graph of the Running AUTOSAR Software Application, Runnables = 50, Paths = 35, Activation Patterns shown in Table \ref{tbl_requirements}.}
\label{fig_application}
\end{figure}
\begin{center}
\small
\begin{minipage}{.5\textwidth}%
\centering
\begin{tabular}{@{}p{0.25cm}lll@{}}
\toprule
C& $r_i$ & $(e_{r_im_1}, e_{r_im_2}, e_{r_im_3})$ & $period$\\ \midrule
\multirow{4}{4em}{c1} 
&$r_1$ & (0.030, 0.060, 0.090) & 1\\
&$r_2$ & (0.041, 0.081, 0.122) & 2\\
&$r_3$ & (0.083, 0.167, 0.250)  & 5\\ 
&$r_4$ & (0.310, 0.620, 0.930) & 10 \\[0.3em]
\hline
\multirow{2}{4em}{c2} 
&$r_1$ & (0.310, 0.620, 0.930) & 10\\
&$r_2$ & (0.310, 0.620, 0.930) & 10\\
&$r_3$ & (0.310, 0.620, 0.930)  & 10\\ 
&$r_4$ & (0.310, 0.620, 0.930) & 10 \\[0.3em]
\hline
\multirow{2}{4em}{c3} 
&$r_1$ & (0.310, 0.620, 0.930) & 10\\
&$r_2$ & (0.291, 0.583, 0.874)) & 10\\
&$r_3$ & (0.291, 0.583, 0.874)  & 20\\ 
&$r_4$ & (0.291, 0.583, 0.874) & 20 \\[0.3em]
\hline
\multirow{2}{4em}{c4} 
&$r_1$ & (0.291, 0.583, 0.874) & 20\\
&$r_2$ & (0.291, 0.583, 0.874)) & 10\\
&$r_3$ & (0.291, 0.583, 0.874)  & 20\\ 
&$r_4$ & (0.093, 0.186, 0.279) & 50 \\[0.3em]
\hline
\multirow{2}{4em}{c5} 
&$r_1$ & (0.420, 0.841, 1.261) & 100\\
&$r_2$ & (0.420, 0.841, 1.261)) & 100\\
&$r_3$ & (0.420, 0.841, 1.261)  & 100\\ 
&$r_4$ & (0.420, 0.841, 1.261) & 100 \\[0.3em]
\bottomrule
\end{tabular}
\captionof{table}{Specification of Components.}
\label{tbl_comps_config}
\end{minipage}~
\begin{minipage}{.45\textwidth}
\begin{center}
    \begin{tabular}{@{}lll@{}}
    \toprule
    Activation, $AP$ & Share & Time, ms \\ \midrule
    $\tau_1$ & 50  & 50\\
    $\tau_1\rightarrow\tau_2$ & 20  & 100\\
    $\tau_1\rightarrow\tau_2\rightarrow\tau_3$ & 20  & 200\\
    $\tau_1\rightarrow\tau_2\rightarrow\tau_3\rightarrow\tau_4$ & 10  & 400\\
    \bottomrule
    \end{tabular}
    \captionof{table}{Activation Patters of Cause-effect Chains, their Share and End-to-end Timing Requirements.}
    \label{tbl_requirements}
\end{center}
\begin{center}
    \begin{tabular}{@{}llll@{}}
    \toprule
    M  & $P_{idle}$& $P_{busy}$& $\lambda$ \\ \midrule
    $m_1$ & 50.0& 140.0 &1.0E-3  \\
    $m_2$ & 10.0& 100.0 &1.0E-4  \\
    $m_3$ & 10.0& 140.0 &1 .0E-5 \\ \bottomrule
    \end{tabular}
    \captionof{table}{Computation Nodes Specification.}
    \label{tbl_nodes_specification}
\end{center}
\end{minipage}
\end{center}

In the next subsequent subsections, we propose a metaheuristic approach which is based on Particle Swarm Optimization (PSO) and hybrid PSO. Furthermore, we elaborate the approach using the presented running example.
